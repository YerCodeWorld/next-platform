// CATEGORIZE exercise type implementation

import type { ExerciseTypeConfig } from '../registry/ExerciseRegistry';
import type { CategorizeContent } from '@repo/api-bridge';
import { validateStringLength, removeDecorators } from '../utils/exerciseHelpers';

// Detection patterns for different variations
const categorizePatterns = {
  // Original: ASIA = @fill('asian countries', 5)
  original: /^[A-Z\s]+\s*=\s*.+$/,
  // Ordering: COLD = Coat | Scarf | Gloves
  ordering: /^[A-Z\s]+\s*=\s*[^=]+(\|[^=]+)+$/,
  // Lake: = @fill('planets', 5) OR Select all planets
  lake: /^(=\s*|Select\s+)/i
};

// Detect CATEGORIZE exercise type and variation
function detectCategorize(lines: string[]): { isMatch: boolean; variation: string } {
  const relevantLines = lines.filter(line => 
    line.trim() && !line.trim().startsWith('//') && !line.includes('@ins(') && !line.includes('@idea(')
  );

  if (relevantLines.length === 0) {
    return { isMatch: false, variation: 'original' };
  }

  // Check for lake variation (starts with = or "Select")
  const hasLakePattern = relevantLines.some(line => categorizePatterns.lake.test(line.trim()));
  if (hasLakePattern) {
    return { isMatch: true, variation: 'lake' };
  }

  // Check for category assignments (contains =)
  const hasCategoryAssignments = relevantLines.some(line => line.includes('='));
  if (!hasCategoryAssignments) {
    return { isMatch: false, variation: 'original' };
  }

  // Determine if it's original or ordering.txt based on pattern complexity
  const hasMultipleItems = relevantLines.some(line => {
    const afterEquals = line.split('=')[1];
    return afterEquals && afterEquals.includes('|');
  });

  if (hasMultipleItems) {
    return { isMatch: true, variation: 'ordering' };
  }

  return { isMatch: true, variation: 'original' };
}

// Parse CATEGORIZE content from lines
function parseCategorize(lines: string[]): CategorizeContent {
  const detection = detectCategorize(lines);
  const variation = detection.variation as 'original' | 'ordering' | 'lake';

  if (variation === 'lake') {
    return parseLakeVariation(lines);
  } else if (variation === 'ordering') {
    return parseOrderingVariation(lines);
  } else {
    return parseOriginalVariation(lines);
  }
}

// Parse original variation: ASIA = @fill('asian countries', 5)
function parseOriginalVariation(lines: string[]): CategorizeContent {
  const categories: Array<{ name: string; items: string[]; hint?: string }> = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('//')) continue;

    const match = trimmed.match(/^([A-Z\s]+)\s*=\s*(.+)$/);
    if (!match || !match[1] || !match[2]) continue;

    const categoryName = match[1].trim();
    const itemsStr = match[2].trim();

    // Extract hint if present
    const hintMatch = itemsStr.match(/@(idea|hint)\s*\(([^)]+)\)/);
    const hint = hintMatch && hintMatch[2] ? hintMatch[2].replace(/['"]/g, '') : undefined;

    // Remove hint from items string
    const cleanItemsStr = itemsStr.replace(/@(idea|hint)\s*\([^)]+\)/, '').trim();

    // Parse items (could be function calls or pipe-separated)
    let items: string[] = [];
    
    if (cleanItemsStr.startsWith('@fill(')) {
      // This will be resolved by the EduScript parser
      items = [cleanItemsStr];
    } else if (cleanItemsStr.includes('|')) {
      items = cleanItemsStr.split('|').map(item => item.trim()).filter(Boolean);
    } else {
      items = [cleanItemsStr];
    }

    categories.push({
      name: categoryName,
      items,
      hint
    });
  }

  return {
    categories,
    variation: 'original'
  };
}

// Parse ordering.txt variation: COLD = Coat | Scarf | Gloves
function parseOrderingVariation(lines: string[]): CategorizeContent {
  const prefilledCategories: Array<{
    name: string;
    correctItems: string[];
    wrongItems: string[];
  }> = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('//')) continue;

    const match = trimmed.match(/^([A-Z\s]+)\s*=\s*(.+)$/);
    if (!match || !match[1] || !match[2]) continue;

    const categoryName = match[1].trim();
    const itemsStr = match[2].trim();

    // For ordering.txt variation, all items listed are correct
    // Wrong items would be generated by the display component
    const items = itemsStr.split('|').map(item => item.trim()).filter(Boolean);

    prefilledCategories.push({
      name: categoryName,
      correctItems: items,
      wrongItems: [] // Will be populated by display logic
    });
  }

  return {
    categories: [], // Not used in ordering.txt variation
    prefilledCategories,
    variation: 'ordering'
  };
}

// Parse lake variation: = @fill('planets', 5) OR Select all planets
function parseLakeVariation(lines: string[]): CategorizeContent {
  let instruction = 'Select the correct items';
  let allItems: string[] = [];
  let targetCategory = '';

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('//')) continue;

    // Check for instruction line
    if (trimmed.startsWith('Select ') || trimmed.includes('instructions =')) {
      instruction = trimmed.replace(/instructions\s*=\s*/, '').replace(/['"]/g, '');
      continue;
    }

    // Correct answers (start with =)
    if (trimmed.startsWith('=')) {
      const itemsStr = trimmed.substring(1).trim();
      if (itemsStr.startsWith('@fill(')) {
        allItems.push(itemsStr);
      } else if (itemsStr.includes('|')) {
        allItems.push(...itemsStr.split('|').map(item => item.trim()).filter(Boolean));
      } else {
        allItems.push(itemsStr);
      }
    }
    
    // Other items (distractors)
    else if (trimmed.includes('@fill(') && !trimmed.startsWith('=')) {
      allItems.push(trimmed);
    }
  }

  return {
    categories: [], // Not used in lake variation
    variation: 'lake',
    instruction,
    allItems,
    targetCategory
  };
}

// Validate CATEGORIZE content
function validateCategorize(content: CategorizeContent): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!content.variation) {
    content.variation = 'original';
  }

  if (content.variation === 'original') {
    if (!content.categories || content.categories.length === 0) {
      errors.push('Original variation requires at least one category');
    } else {
      content.categories.forEach((category, index) => {
        const nameValidation = validateStringLength(category.name, 1, 50, 'Category name');
        if (nameValidation) {
          errors.push(`Category ${index + 1}: ${nameValidation}`);
        }
        if (!category.items || category.items.length === 0) {
          errors.push(`Category ${index + 1}: Must have at least one item`);
        }
      });
    }
  } else if (content.variation === 'ordering') {
    if (!content.prefilledCategories || content.prefilledCategories.length === 0) {
      errors.push('Ordering variation requires at least one prefilled category');
    }
  } else if (content.variation === 'lake') {
    if (!content.allItems || content.allItems.length === 0) {
      errors.push('Lake variation requires items to select from');
    }
    if (!content.instruction) {
      errors.push('Lake variation requires an instruction');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

// Convert content back to LanScript
function categorizeLanScript(content: CategorizeContent): string {
  const lines: string[] = [];

  if (content.variation === 'original') {
    content.categories?.forEach(category => {
      let line = `${category.name} = ${category.items.join(' | ')}`;
      if (category.hint) {
        line += ` @idea("${category.hint}")`;
      }
      lines.push(line);
    });
  } else if (content.variation === 'ordering') {
    content.prefilledCategories?.forEach(category => {
      lines.push(`${category.name} = ${category.correctItems.join(' | ')}`);
    });
  } else if (content.variation === 'lake') {
    if (content.instruction) {
      lines.push(`// ${content.instruction}`);
    }
    if (content.allItems && content.allItems.length > 0) {
      const correctItems = content.allItems.filter(item => !item.startsWith('@fill('));
      const functionItems = content.allItems.filter(item => item.startsWith('@fill('));
      
      if (correctItems.length > 0) {
        lines.push(`= ${correctItems.join(' | ')}`);
      }
      
      functionItems.forEach(item => {
        lines.push(item);
      });
    }
  }

  return lines.join('\n');
}

// Export the exercise configuration
export const categorizeExercise: ExerciseTypeConfig<CategorizeContent> = {
  type: 'CATEGORIZER',
  displayName: 'Categorize',
  description: 'Organize items into different categories',
  icon: 'category',
  
  detectPattern: (lines: string[]) => detectCategorize(lines).isMatch,
  parseContent: parseCategorize,
  validateContent: (content: CategorizeContent) => {
    const result = validateCategorize(content);
    return {
      isValid: result.isValid,
      errors: result.errors,
      warnings: []
    };
  },
  toLanScript: categorizeLanScript,
  
  errorMessages: {
    parseError: (error: Error) => `Failed to parse categorize exercise: ${error.message}`,
    validationError: (errors: string[]) => `Validation failed: ${errors.join(', ')}`,
    displayError: (error: Error) => `Display error: ${error.message}`
  },
  
  DisplayComponent: undefined, // Will be provided by the main app
  BuilderComponent: undefined  // Will be provided by the main app
};